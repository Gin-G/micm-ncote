!> \file kinetics_module.F90
!!  Contains type definitions for MICM kinetics

module kinetics_module

!*****************************************************************************************
! This module is completely auto-generated by Configurator
!*****************************************************************************************

  USE ccpp_kinds, ONLY: r8 => kind_phys

implicit none

private
public :: kinetics_type

! rateConst are computed at the beginning of the 
!   chemistry_box_solver time step.
!   They are not computed for internal steps of the
!   box-model time-step advancer
! rateConst will be thread-safe memory provided elsewhere.
! rate_constant_store will be an accessor to memory
! For now, it is allocated here. It is not thread safe

! Filter with CPP for PGI compiler
!> \section arg_table_kinetics_type
!! \htmlinclude kinetics_type.html
!!

type kinetics_type
  private
  integer :: nReact
  real(r8), allocatable :: rateConst(:)
  real(r8)              :: number_density   ! total number density (molecules/cm^3)
contains
  private
  procedure, public :: rateConst_init 
  procedure, public :: rateConst_update
  procedure, public :: rateConst_print
  procedure, public :: force
  procedure, public :: jac
  final             :: DasEnder
end type kinetics_type

contains

  !------------------------------------------------------
  ! allocate rateConst member array
  !------------------------------------------------------
  subroutine rateConst_init( this, nRxt )
      
    class(kinetics_type) :: this
    integer, intent(in)  :: nRxt    ! total number of reactions

    this%nReact = nRxt
    if( .not. allocated(this%rateConst)) then
      allocate( this%rateConst(nRxt) )
    else
      write(*,*) 'rateConst_init: rateConst already allocated'
    endif

  end subroutine rateConst_init

  !------------------------------------------------------
  ! update rateConst
  ! Execute once for the chemistry-time-step advance
  ! Not called from the solver
  !------------------------------------------------------
  subroutine rateConst_update( this, k_rateConst, j_rateConst, c_m )

    class(kinetics_type) :: this
    real(r8), intent(in) :: k_rateConst(:) ! externally supplied rate constants
    real(r8), intent(in) :: j_rateConst(:)
    real(r8), intent(in) :: c_m ! total number density
  
    integer :: i, size_krateConst, size_jrateConst
    
    size_krateConst=size(k_rateConst)
    size_jrateConst=size(j_rateConst)

    this%number_density=c_m

    associate( rateConstants => this%rateConst )
      ! Rate Constants
    
      ! Assign the k_rateConst to the beginning of the rateConstants array
      if (size_krateConst>  0) rateConstants(1:size_krateConst)=k_rateConst(1:size_krateConst)

      ! Assign the j_rateConst to the rateConstants array after the k_rateConst
      if (size_jrateConst > 0) rateConstants(size_krateConst+1:size_krateConst+size_jrateConst) = j_rateConst(1:size_jrateConst)
    
    end associate

  end subroutine rateConst_update

  subroutine rateConst_print( this )

    class(kinetics_type) :: this

    write(*,*) 'rate constants:'
    write(*,'(1p,5(1x,g0))') this%rateConst(:)

  end subroutine rateConst_print

  !---------------------------
  !  cleanup when k_rateConst type is removed
  !---------------------------
  subroutine DasEnder( this )

    type(kinetics_type) :: this

    if( allocated( this%rateConst ) ) then
       deallocate( this%rateConst )
    endif

  end subroutine DasEnder

  !---------------------------
  ! Compute time rate of change of each molecule (vmr) given reaction rates
  !---------------------------
  function force( this, vmr )

    class(kinetics_type) :: this
    real(r8), intent(in)::  vmr(:)              ! volume mixing ratios of each component in order
    real(r8)            ::  force(size(vmr))    ! rate of change of each molecule

    real(r8) :: rates(this%nReact)          ! rates of each reaction

    call compute_rates(this, vmr, rates)

! Forcing
 force(1) = (0) * rates(1)
 force(3) = (-1) * rates(1) + (-1) * rates(2) + (1) * rates(6)
 force(2) = (1) * rates(1) + (1) * rates(2) + (-1) * rates(3) + (-1) * rates(4) + (2) * rates(5) + (1) * rates(7)
 force(4) = (0) * rates(2) + (2) * rates(3) + (-1) * rates(4) + (-1) * rates(5) + (1) * rates(6) + (1) * rates(7)
 force(5) = (-1) * rates(3) + (1) * rates(4) + (-1) * rates(6) + (-1) * rates(7)

  end function force

  !---------------------------
  ! Compute sensitivity of molecular forcing to each vmr (derivative of force w.r.t. each vmr)
  !---------------------------
  function jac( this, vmr )

    class(kinetics_type) :: this
    real(r8), intent(in)::  vmr(:)         ! volume mixing ratios of each component in order
    real(r8) :: jac(size(vmr),size(vmr))   ! sensitivity of forcing to changes in each vmr
    real(r8) :: number_density_air, number_density_air_squared, number_density_air_cubed
    associate( number_density_air => this%number_density )

    number_density_air_squared = number_density_air*number_density_air
    number_density_air_cubed = number_density_air*number_density_air*number_density_air
    ! Jacobian
    jac(:,:) = 0._r8

    associate( rateConstants => this%rateConst )

  ! Jacobian  


jac(1,1)  = jac(1,1) + (0) * rateConstants(1) * vmr(3) * number_density_air
jac(1,3)  = jac(1,3) + (0) * rateConstants(1) * vmr(1) * number_density_air
jac(3,1)  = jac(3,1) + (-1) * rateConstants(1) * vmr(3) * number_density_air
jac(3,3)  = jac(3,3) + (-1) * rateConstants(1) * vmr(1) * number_density_air
jac(3,3)  = jac(3,3) + (-1) * rateConstants(2) * vmr(4) * number_density_air
jac(3,4)  = jac(3,4) + (-1) * rateConstants(2) * vmr(3) * number_density_air
jac(3,5)  = jac(3,5) + (1) * rateConstants(6)
jac(2,1)  = jac(2,1) + (1) * rateConstants(1) * vmr(3) * number_density_air
jac(2,3)  = jac(2,3) + (1) * rateConstants(1) * vmr(1) * number_density_air
jac(2,3)  = jac(2,3) + (1) * rateConstants(2) * vmr(4) * number_density_air
jac(2,4)  = jac(2,4) + (1) * rateConstants(2) * vmr(3) * number_density_air
jac(2,2)  = jac(2,2) + (-1) * rateConstants(3) * vmr(5) * number_density_air
jac(2,5)  = jac(2,5) + (-1) * rateConstants(3) * vmr(2) * number_density_air
jac(2,2)  = jac(2,2) + (-1) * rateConstants(4) * vmr(4) * number_density_air_squared
jac(2,4)  = jac(2,4) + (-1) * rateConstants(4) * vmr(2) * number_density_air_squared
jac(2,4)  = jac(2,4) + (2) * rateConstants(5)
jac(2,5)  = jac(2,5) + (1) * rateConstants(7)
jac(4,3)  = jac(4,3) + (0) * rateConstants(2) * vmr(4) * number_density_air
jac(4,4)  = jac(4,4) + (0) * rateConstants(2) * vmr(3) * number_density_air
jac(4,2)  = jac(4,2) + (2) * rateConstants(3) * vmr(5) * number_density_air
jac(4,5)  = jac(4,5) + (2) * rateConstants(3) * vmr(2) * number_density_air
jac(4,2)  = jac(4,2) + (-1) * rateConstants(4) * vmr(4) * number_density_air_squared
jac(4,4)  = jac(4,4) + (-1) * rateConstants(4) * vmr(2) * number_density_air_squared
jac(4,4)  = jac(4,4) + (-1) * rateConstants(5)
jac(4,5)  = jac(4,5) + (1) * rateConstants(6)
jac(4,5)  = jac(4,5) + (1) * rateConstants(7)
jac(5,2)  = jac(5,2) + (-1) * rateConstants(3) * vmr(5) * number_density_air
jac(5,5)  = jac(5,5) + (-1) * rateConstants(3) * vmr(2) * number_density_air
jac(5,2)  = jac(5,2) + (1) * rateConstants(4) * vmr(4) * number_density_air_squared
jac(5,4)  = jac(5,4) + (1) * rateConstants(4) * vmr(2) * number_density_air_squared
jac(5,5)  = jac(5,5) + (-1) * rateConstants(6)
jac(5,5)  = jac(5,5) + (-1) * rateConstants(7)
    end associate
    end associate

  end function jac

  !---------------------------
  ! Compute reaction rates, given vmr of each species and rate constants
  !---------------------------
  subroutine compute_rates(this, vmr, rates )

    class(kinetics_type)  :: this
    real(r8), intent(in)  :: vmr(:)     ! volume mixing ratios of each component in order
    real(r8), intent(out) :: rates(:)   ! rates for each reaction (sometimes called velocity of reaction)
    real(r8) :: number_density_air, number_density_air_squared, number_density_air_cubed

    associate( rateConstants => this%rateConst )
    associate( number_density_air => this%number_density )

    number_density_air_squared = number_density_air*number_density_air
    number_density_air_cubed = number_density_air*number_density_air*number_density_air

! Rates

! N2_O1D
rates(1) = rateConstants(1) * vmr(1) * vmr(3) * number_density_air

! O1D_O2
rates(2) = rateConstants(2) * vmr(3) * vmr(4) * number_density_air

! O_O3
rates(3) = rateConstants(3) * vmr(2) * vmr(5) * number_density_air

! O_O2_M
rates(4) = rateConstants(4) * vmr(2) * vmr(4) * number_density_air_squared

! O2
rates(5) = rateConstants(5) * vmr(4)

! O3
rates(6) = rateConstants(6) * vmr(5)

! O3_1
rates(7) = rateConstants(7) * vmr(5)
    end associate
    end associate

  end subroutine compute_rates

end module kinetics_module
